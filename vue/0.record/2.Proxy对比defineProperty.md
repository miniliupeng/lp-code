`Object.defineProperty` 是 Vue 2.x 响应式系统的基石，而 `Proxy` 则是 Vue 3.x 的心脏。Vue 3 选择 `Proxy` 是为了解决 `Object.defineProperty` 存在的多个固有缺陷。

### 核心区别概览

| 特性 | `Object.defineProperty` (Vue 2) | `Proxy` (Vue 3) |
| :--- | :--- | :--- |
| **监听范围** | **属性级别**：必须明确指定要监听哪个对象的哪个属性。 | **对象级别**：直接代理整个对象，而不是对象的属性。 |
| **初始化** | **递归遍历**：初始化时需要一次性遍历对象的所有属性进行数据劫持。 | **懒代理**：只在对象被创建时代理第一层，嵌套对象的代理在被访问时才创建。 |
| **新增属性** | **无法监听**：无法自动检测到对象属性的新增或删除。 | **可监听**：天然支持监听属性的新增和删除。 |
| **数组监听** | **有缺陷**：无法监听数组通过索引的修改和 `.length` 属性的修改。 | **完美支持**：可以完美地监听到数组的各种操作。 |
| **`this` 指向** | **无问题**：`getter/setter` 中的 `this` 指向是固定的。 | **需处理**：需要配合 `Reflect` 和 `receiver` 来保证 `this` 指向代理对象。 |
| **API 数量** | 2个 (`get`/`set`) | 13个 (`get`, `set`, `has`, `deleteProperty` 等) |
| **兼容性** | **良好** (支持 IE9+) | **现代浏览器** (不支持 IE11) |

---

### 详细对比

#### 1. 监听范围：属性 vs. 对象

这是最本质的区别。

-   **`Object.defineProperty`**: 它的工作模式是“劫持”一个对象的**特定属性**的 `getter` 和 `setter`。如果你想让一个对象的所有属性都变成响应式的，你必须用 `Object.keys()` 遍历这个对象，然后对**每一个属性**都调用一次 `Object.defineProperty`。

    ```javascript
    // Vue 2 伪代码
    function reactive(obj) {
      Object.keys(obj).forEach(key => {
        let value = obj[key];
        Object.defineProperty(obj, key, {
          get() {
            console.log(`正在读取 ${key}`);
            // track(obj, key); // 依赖收集
            return value;
          },
          set(newValue) {
            console.log(`正在设置 ${key}`);
            value = newValue;
            // trigger(obj, key); // 派发更新
          }
        });
      });
      return obj;
    }

    const data = reactive({ a: 1, b: 2 });
    data.a; // ok
    data.b = 3; // ok
    ```

-   **`Proxy`**: 它不对属性进行操作，而是直接在目标对象之上架设一个**拦截层**。任何对这个代理对象的操作（比如读取、设置、删除属性等）都会先经过这个拦截层。你只需要创建一次 `Proxy`，整个对象就都被代理了。

    ```javascript
    // Vue 3 伪代码
    function reactive(obj) {
      return new Proxy(obj, {
        get(target, key, receiver) {
          console.log(`正在读取 ${key}`);
          // track(target, key); // 依赖收集
          return Reflect.get(target, key, receiver);
        },
        set(target, key, value, receiver) {
          console.log(`正在设置 ${key}`);
          const result = Reflect.set(target, key, value, receiver);
          // trigger(target, key); // 派发更新
          return result;
        }
      });
    }

    const data = reactive({ a: 1, b: 2 });
    ```

**优势体现**：`Proxy` 的实现更简洁、更优雅，性能上在初始化阶段也更有优势，因为它不需要一上来就遍历所有属性。

#### 2. 对新增/删除属性的监听

这是 `Object.defineProperty` 的一个著名痛点。

-   **`Object.defineProperty`**: 由于它只在初始化时对已存在的属性进行劫持，所以你**后续向对象添加的新属性不会是响应式的**。

    ```javascript
    const data = reactive({ a: 1 });
    data.b = 2; // Vue 2 无法检测到这个变化，界面不会更新
    delete data.a; // Vue 2 也无法检测到这个删除操作
    ```

    为了解决这个问题，Vue 2 必须提供一个特殊的 API：`Vue.set` (或 `this.$set`) 和 `Vue.delete` (或 `this.$delete`)。

-   **`Proxy`**: `Proxy` 天然就能监听到这些操作，因为它代理的是整个对象。

    ```javascript
    const data = reactive({ a: 1 });
    data.b = 2; // Proxy 的 set 陷阱会被触发，响应式系统正常工作
    delete data.a; // Proxy 的 deleteProperty 陷阱会被触发，同样正常工作
    ```

**优势体现**：`Proxy` 让开发者可以像操作普通 JavaScript 对象一样自然地操作响应式对象，心智负担更小，不再需要记忆特殊的 API。

#### 3. 对数组的监听

这是 `Object.defineProperty` 的另一个主要缺陷。

-   **`Object.defineProperty`**: 它无法监听到以下两种数组操作：
    1.  通过索引直接修改数组项：`arr[0] = 'new value'`
    2.  修改数组的长度：`arr.length = 0`

    Vue 2 为了解决这个问题，采取了**重写数组原型方法**的策略。它会拦截像 `push`, `pop`, `splice` 等这些会修改原数组的方法，在这些方法执行前后进行依赖通知。但对于上述两种操作，它依然无能为力。

-   **`Proxy`**: `Proxy` 可以完美地监听到数组的所有操作。`arr[0] = 'new value'` 会触发 `set` 陷阱，`arr.length = 0` 也会触发 `set` 陷阱。

**优势体现**：`Proxy` 对数组的支持是全面且无死角的，使得数组的响应式行为和普通对象完全一致，更加符合直觉。

### 总结：为什么 Vue 3 拥抱 Proxy

尽管 `Proxy` 牺牲了对 IE11 的兼容性，但它带来的好处是巨大的：

1.  **更强大的功能**：解决了 `Object.defineProperty` 无法监听属性增删、数组索引修改等核心痛点。
2.  **更优的性能**：初始化时不需要深度遍历和递归设置，性能更好。只有当访问到深层属性时，才会进行懒代理。
3.  **更简洁的代码**：响应式系统的核心代码不再需要处理那么多的边缘情况（如 `Vue.set`、重写数组方法等），代码更健壮、更易于维护。

总而言之，`Proxy` 提供了在语言层面上的原生代理能力，让 Vue 3 的响应式系统实现得更加强大、高效和符合 JavaScript 的自然语法。