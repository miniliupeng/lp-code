# 第一部分：TypeScript 类型基础

### 1. 核心原始与结构类型

#### 1.1 原始类型 (Primitive Types)

JavaScript 有七种原始类型，TypeScript 都为其提供了对应的类型注解。

-   **`string`**: 表示文本数据，例如 `"hello, world"`。
-   **`number`**: 表示数字，包括整数和浮点数，例如 `42` 或 `3.14`。
-   **`boolean`**: 表示逻辑值，只有 `true` 和 `false`。
-   **`null`**: 表示一个空值或“无”的值。
-   **`undefined`**: 表示一个未定义的值。
-   **`symbol`**: 表示全局唯一的引用。
-   **`bigint`**: 表示任意精度的整数。

```typescript
let name: string = "Alice";
let age: number = 30;
let isStudent: boolean = false;
let car: null = null;
let anything: undefined = undefined;
let uniqueKey: symbol = Symbol("key");
let largeNumber: bigint = 9007199254740991n;
```

#### 1.2 结构类型 (Structural Types)

-   **对象类型 (`object` & 接口 `interface`)**:
    TypeScript 使用接口（`interface`）或类型别名（`type`）来定义对象的结构。

    ```typescript
    interface Person {
      name: string;
      age: number;
    }

    let person: Person = {
      name: "Bob",
      age: 40,
    };
    ```

    **属性修饰符**: 我们可以对接口中的属性进行修饰，最常见的是**可选修饰符 (`?`)** 和**只读修饰符 (`readonly`)**。

    - **可选属性 (`?`)**: 在属性名后添加问号，表示该属性在对象中可以不存在。
        ```typescript
        interface PersonWithOptionalEmail {
          name: string;
          age: number;
          email?: string; // email 是可选的
        }
        
        const person1: PersonWithOptionalEmail = { name: "Alice", age: 30 }; // OK
        const person2: PersonWithOptionalEmail = { name: "Bob", age: 40, email: "bob@example.com" }; // OK
        
        // 访问可选属性时，其类型会自动联合 undefined
        // person1.email?.toLowerCase(); // 需要使用可选链 ?. 来安全访问
        ```

    - **只读属性 (`readonly`)**: 在属性名前添加 `readonly`，表示该属性在对象初始化后不能被重新赋值。
        ```typescript

        interface Point {
          readonly x: number;
          readonly y: number;
        }

        const p: Point = { x: 10, y: 20 };
        // p.x = 5; // 错误: 无法分配到 "x" ，因为它是只读属性。
        ```

-   **数组类型 (`Array`)**:
    有两种常见的方式来定义数组类型。

    ```typescript
    // 方式一：类型 + 方括号
    let list1: number[] = [1, 2, 3];

    // 方式二：数组泛型
    let list2: Array<number> = [1, 2, 3];
    ```

    > **Readonly 数组**: 你可以在数组类型前加上 `readonly` 关键字，来创建一个只读数组。这实际上会得到一个 `ReadonlyArray<T>` 类型，它没有 `push`, `pop` 等会修改原数组的方法，从而保证了数组的不可变性。
    >
    > ```typescript
    > const readonlyList: readonly number[] = [1, 2, 3];
    > // readonlyList.push(4); // 错误: 类型“readonly number[]”上不存在属性“push”。
    > ```

-   **元组类型 (`Tuple`)**:
    元组允许你表示一个已知元素数量和类型的数组，各元素的类型不必相同。

    ```typescript
    let user: [string, number, boolean] = ["Alice", 25, true];
    // 访问元组元素时，会得到正确的类型提示
    console.log(user[0].substring(1)); // 'lice'
    // console.log(user[1].substring(1)); // 错误: 'number' 类型没有 'substring' 方法
    ```

    元组在某些场景下比数组更严谨，例如，当你希望一个数组的长度固定，并且每个索引位置上的类型都确定时。TypeScript 4.0 之后，元组的能力得到了进一步增强：

    - **具名元组 (Labeled Tuples)**: 你可以为元组中的每个元素命名，以增强可读性。
        ```typescript
        let namedUser: [name: string, age: number, active: boolean] = ["Alice", 25, true];
        ```
    - **可选元素**: 你可以使用 `?` 来标记元组中的某个元素是可选的。
        ```typescript
        let optionalTuple: [string, number?] = ["Bob"];
        console.log(optionalTuple.length); // 此时 tuple 的 length 类型是 1 | 2
        ```
    - **边界检查**: 使用元组可以帮助 TypeScript 在编译时检查出越界访问，包括解构赋值时的隐式越界。
        ```typescript
        const fixedTuple: [string, number] = ['hello', 1];
        // const [str, num, extra] = fixedTuple; // 错误: 索引 "2" 处没有元素。
        ```

    > **Readonly 元组**: `readonly` 同样可以用于元组，创建一个只读元组。
    >
    > ```typescript
    > const readonlyTuple: readonly [string, number] = ["hello", 10];
    > // readonlyTuple[0] = "world"; // 错误: 无法分配到 "0" ，因为它是只读属性。
    > ```

#### 1.3 特殊的内置类型

-   **`any`**:
    `any` 类型是 TypeScript 的“后门”，它告诉编译器不要对该值进行任何类型检查。应极力避免使用 `any`，因为它会削弱 TypeScript 带来的类型安全优势。

    ```typescript
    let notSure: any = 4;
    notSure.ifItExists(); // OK, ifItExists might exist at runtime
    notSure.toFixed();   // OK, toFixed exists (but the compiler doesn't check)
    ```

-   **`unknown`**:
    `unknown` 是 `any` 的类型安全对应物。当你需要表示一个未知类型的值时，应优先使用 `unknown`。在使用 `unknown` 类型的值之前，必须先进行类型收窄（narrowing），例如使用类型断言或类型守卫。

    ```typescript
    let maybe: unknown;

    if (typeof maybe === 'string') {
      // 在这个代码块中，TypeScript 知道 `maybe` 是一个 string
      console.log(maybe.toUpperCase());
    }
    ```

-   **`void`**:
    `void` 表示没有任何类型。通常用作不返回任何值的函数的返回值类型。

    ```typescript
    function warnUser(): void {
      console.log("This is a warning message");
    }
    ```

    **注意**: `void` 和 `undefined` 在函数返回值中有一个细微的区别。如果一个函数没有 `return` 语句，或者 `return` 一个没有明确值的值，其返回值类型会被推断为 `void`。只有当函数显式 `return undefined;` 时，其返回值类型才会被推断为 `undefined`。

-   **`never`**:
    `never` 类型表示的是那些永不存在的值的类型。例如，一个总是抛出异常或无限循环的函数的返回值类型就是 `never`。

    ```typescript
    // 抛出异常的函数
    function error(message: string): never {
      throw new Error(message);
    }

    // 无限循环的函数
    function infiniteLoop(): never {
      while (true) {}
    }
    ```

---

### 2. 字面量类型 (Literal Types) 与枚举 (Enums)

#### 2.1 字面量类型

字面量类型允许你将变量限制为某个具体的字符串、数字或布尔值。

```typescript
let direction: "left" | "right" | "up" | "down";
direction = "left"; // OK
// direction = "north"; // Error: Type '"north"' is not assignable to type '"left" | "right" | "up" | "down"'.

let specificNumber: 1 | 2 | 3 = 1;
```

#### 2.2 枚举 (Enums)

枚举是 TypeScript 添加到 JavaScript 的一项功能，它允许你为一组数值定义更友好的名字。

```typescript
enum Direction {
  Up,    // 默认从 0 开始
  Down,
  Left,
  Right,
}

let go: Direction = Direction.Up; // go 的值为 0
```

**枚举的类型安全问题与 `const enum`**:
常规的 `enum` 会在编译后的 JavaScript 代码中生成一个真实的对象。如果你追求更高的性能和更强的类型约束，可以使用 `const enum`。`const enum` 在编译阶段会被完全移除，并在使用处直接内联其值。

```typescript
const enum ConstDirection {
  Up,
  Down,
}

let myConstDir = ConstDirection.Up; // 编译后会变成 let myConstDir = 0;
```

---

### 3. 函数类型 (Function Types)

#### 3.1 定义函数签名

你可以使用类型别名或接口来定义一个函数的形状。

```typescript
type AddFunc = (a: number, b: number) => number;

const add: AddFunc = (x, y) => {
  return x + y;
};
```

#### 3.2 可选参数、默认参数、剩余参数

```typescript
// 可选参数
function buildName(firstName: string, lastName?: string) {
  // ...
}

// 默认参数
function calculatePrice(price: number, discount: number = 0.05) {
  // ...
}

// 剩余参数
function sum(...numbers: number[]): number {
  return numbers.reduce((total, num) => total + num, 0);
}
```

#### 3.3 函数重载 (Overloads)

函数重载允许你为一个函数根据不同的参数类型或数量提供多个函数类型定义。

```typescript
function getLength(input: string): number;
function getLength(input: any[]): number;
function getLength(input: any): number {
  return input.length;
}

getLength("hello"); // -> number
getLength([1, 2, 3]); // -> number
```

---

### 4. Class 类型

TypeScript 完整支持 ES6 的 `class` 语法，并添加了类型注解和成员修饰符。

#### 4.1 成员修饰符

-   **`public`** (默认): 成员可以在任何地方被访问。
-   **`private`**: 成员只能在类的内部被访问。
-   **`protected`**: 成员只能在类的内部及其子类中被访问。
-   **`readonly`**: 只读修饰符，属性只能在声明时或构造函数里被初始化。

```typescript
class Animal {
  private name: string;
  public constructor(name: string) {
    this.name = name;
  }
  public move(distance: number): void {
    console.log(`${this.name} moved ${distance}m.`);
  }
}
```

#### 4.2 抽象类 (Abstract Classes)

抽象类是作为其他派生类的基类的。它们不能被实例化。抽象类中的抽象方法必须在派生类中被实现。

```typescript
abstract class Vehicle {
  abstract startEngine(): void;

  drive(): void {
    console.log("Driving...");
  }
}

class Car extends Vehicle {
  startEngine(): void {
    console.log("Car engine started.");
  }
}

// const v = new Vehicle(); // Error: Cannot create an instance of an abstract class.
const carInstance = new Car();
carInstance.startEngine();
carInstance.drive();
```

#### 4.3 `interface` 与 `type` 的选择

在 TypeScript 中，`interface` 和 `type` 别名在很多情况下可以互换使用来定义对象的结构。但遵循社区的最佳实践，可以使代码更清晰：

-   **`interface`**: 优先使用 `interface` 来描述**对象或类的结构**。`interface` 支持“声明合并”（declaration merging），这意味着你可以多次声明同一个 `interface`，它们会自动合并，这在扩展第三方库的类型时非常有用。

    ```typescript
    interface Window {
      myAppConfig: object;
    }
    // ... 在另一个文件中
    interface Window {
      anotherPluginConfig: object;
    }
    // Window 接口现在同时拥有 myAppConfig 和 anotherPluginConfig 属性
    ```

-   **`type`**: 使用 `type` 别名来定义**联合类型、元组、函数签名**，或任何其他需要名称的复杂类型。

    ```typescript
    type StringOrNumber = string | number;
    type Point = [number, number];
    type Callback = (data: string) => void;
    type UserWithId = User & { id: string }; // 交叉类型
    ```

**总结**: 如果你在定义一个对象的“形状”，优先考虑 `interface`。如果你在为一组类型组合、函数签名等起一个别名，`type` 是更好的选择。

---

### 5. `object`, `Object`, 与 `{}` 的辨析

在 TypeScript 中，这三个类型很容易混淆，但它们的含义截然不同。

-   **`Object`**: 代表所有拥有原型链的类型（几乎所有类型）。它包含了所有的原始类型和非原始类型。**在任何情况下，你都应该避免使用 `Object` 作为类型**，因为它几乎不提供任何类型检查，其作用类似于 `any`。

-   **`object`**: `object` 类型是 `Object` 的一个更严格的版本，它代表**所有非原始类型**，即数组、对象和函数。你不能将 `string`, `number`, `boolean` 等原始类型赋值给 `object`。

    ```typescript
    let nonPrimitive: object;
    nonPrimitive = {};       // OK
    nonPrimitive = [];       // OK
    nonPrimitive = () => {}; // OK
    // nonPrimitive = "hello"; // 错误
    // nonPrimitive = 42;      // 错误
    ```

-   **`{}` (空对象类型)**: 这个类型同样可以接受任何非 `null`/`undefined` 的值。然而，你无法访问其上的任何属性，即使是实际传入的对象上有。因此，**也应该避免使用 `{}` 作为类型**。

**总结与建议**:
-   永远不要使用 `Object` 或 `{}`。
-   当你需要一个非原始类型时，使用 `object` 是一个相对安全的选择。但更好的做法是使用更具体的类型，例如 `Record<string, unknown>` 来表示一个普通对象，或 `unknown[]` 来表示数组。

---

### 6. 泛型入门 (Generics)

泛型是创建可重用组件的强大工具，它允许组件在处理多种类型的数据时依然保持类型安全。

#### 6.1 泛型函数

```typescript
function identity<T>(arg: T): T {
  return arg;
}

let output1 = identity<string>("myString"); // type of output1 is 'string'
let output2 = identity(100); // 类型推断，type of output2 is 'number'
```

#### 6.2 泛型接口与泛型类

```typescript
// 泛型接口
interface GenericIdentityFn<T> {
  (arg: T): T;
}

// 泛型类
class GenericNumber<T> {
  zeroValue: T;
  add: (x: T, y: T) => T;
}
```

---

### 扩展阅读

#### `unique symbol`

JavaScript 中的 `Symbol` 用于创建唯一值，但在 TypeScript 的类型系统中，普通的 `symbol` 类型并不具备这种唯一性。为了在类型层面实现“独一无二”，TypeScript 引入了 `unique symbol` 类型。它必须由 `const` 声明或 `readonly static` 属性，并且其值必须是 `Symbol()` 的直接调用。

```typescript
const uniqueSymbolA: unique symbol = Symbol("a");
const uniqueSymbolB: unique symbol = Symbol("b");

// const uniqueSymbolC: unique symbol = uniqueSymbolA; // 错误: 类型 "typeof uniqueSymbolA" 不能赋值给类型 "typeof uniqueSymbolB"
```
