# 03-关键渲染路径（Critical Rendering Path）

关键渲染路径（CRP）是指浏览器从接收到 HTML、CSS 和 JavaScript 资源开始，到最终将它们渲染成像素显示在屏幕上所经历的一系列步骤。**优化关键渲染路径是提升页面首屏加载速度的核心**。

我们可以将 CRP 分为以下几个关键阶段：

## 1. 构建对象模型 (Object Model)

当渲染进程接收到导航确认，开始解析数据时，主线程首先会将 HTML 和 CSS 文本转换成浏览器能够理解的内部数据结构。

### a. 构建 DOM 树 (Document Object Model)

*   **输入**：HTML 文本。
*   **过程**：UI 渲染线程自上而下解析 HTML 标记，逐个生成节点对象，并根据它们之间的嵌套关系构建起一个树状结构。
*   **输出**：DOM 树。

这个过程是**渐进式**的。浏览器不需要等到整个 HTML 文档下载完毕才开始解析和构建 DOM，而是一边接收数据一边进行。

### b. 构建 CSSOM 树 (CSS Object Model)

*   **输入**：CSS 代码（来自 `<link>` 标签、`<style>` 标签或内联样式）。
*   **过程**：UI 渲染线程解析 CSS 规则。与 HTML 不同，CSS 的解析**不是渐进式**的，因为后面的规则可能会覆盖前面的规则。浏览器需要下载并解析完所有的 CSS 代码，才能确认每个 DOM 节点的最终样式。
*   **输出**：CSSOM 树。

**注意：CSSOM 的构建会阻塞渲染。** 在 CSSOM 树完全构建完成之前，浏览器不会进入后续的渲染阶段。这就是为什么我们通常建议将 CSS `<link>` 标签放在 HTML 的 `<head>` 部分，以便浏览器能尽早发现并下载 CSS，从而缩短阻塞时间。

## 2. JavaScript 的影响：解析器阻塞

当 HTML 解析器在构建 DOM 的过程中遇到 `<script>` 标签时，情况会变得特殊。

*   **默认行为（无 `async` 或 `defer`）**：
    1.  HTML 解析暂停。
    2.  浏览器开始下载 JavaScript 文件。
    3.  下载完成后，JS 引擎线程立即执行该脚本。
    4.  脚本执行完毕后，HTML 解析器才恢复工作。

**为什么 JS 会阻塞 DOM 构建？**
因为 JavaScript 可以通过 `document.write()` 或其他 DOM API 来修改 DOM 结构。浏览器无法预知脚本会做什么，所以它必须停下来，等待脚本执行完毕，以确保后续的 DOM 构建是基于一个确定的、未被修改的状态。

**JS 同样会阻塞 CSSOM 构建**。如果脚本试图查询一个节点的样式（例如 `element.style.width`），它必须等待所有 CSS 都被下载和解析完毕，以获取最准确的样式信息。因此，JS 的执行会间接地被 CSS 阻塞。

**优化方案：`async` 和 `defer`**
为了减少 JS 阻塞带来的性能影响，我们可以使用这两个属性：
*   **`async`**：脚本的下载和 HTML 解析可以并行进行。一旦脚本下载完成，HTML 解析会立即暂停，开始执行脚本。执行完毕后，再恢复 HTML 解析。它不保证脚本的执行顺序。
*   **`defer`**：脚本的下载和 HTML 解析也可以并行进行。但脚本的执行会被推迟到整个 HTML 文档解析完毕（DOM 构建完成）之后，`DOMContentLoaded` 事件触发之前。它会按照脚本在 HTML 中出现的顺序来执行。

## 3. 构建渲染树 (Render Tree)

当浏览器同时拥有了 DOM 树和 CSSOM 树之后，就可以将它们结合起来，创建**渲染树**。

*   **过程**：浏览器会从 DOM 树的根节点开始遍历，对于每个**可见**的节点，找到它在 CSSOM 树中对应的样式规则，并应用它们。
*   **关键点**：渲染树只包含页面上实际可见的元素。像 `<head>`、`<script>` 标签，或者设置了 `display: none;` 的节点，都不会被包含在渲染树中。而 `visibility: hidden;` 的节点虽然不可见，但仍然占据布局空间，所以会包含在渲染树里。

## 4. 布局 (Layout / Reflow)

有了渲染树，浏览器就知道了哪些节点需要被渲染以及它们的样式，但还不知道它们在屏幕上的确切位置和大小。**布局**阶段就是为了计算这些几何信息。

*   **过程**：浏览器从渲染树的根节点开始，递归地计算每个节点的几何信息（位置、尺寸）。
*   **输出**：一个包含了所有元素精确位置和大小信息的“盒子模型”。

页面上的任何一个微小的改动，比如窗口大小变化、元素尺寸变化、内容改变导致的高度变化等，都可能引发整个或部分渲染树的**重新布局**，这个过程也叫**回流 (Reflow)**。回流是一个非常耗费性能的操作。

## 5. 绘制 (Paint)

布局阶段完成后，浏览器知道了每个元素的几何信息和样式。**绘制**阶段就是将这些信息转换成屏幕上的实际像素。

*   **过程**：UI 渲染线程会遍历渲染树，调用图形库的 API，将每个节点的背景、颜色、边框、文字等内容绘制出来。这个过程会生成一系列的绘制指令。

当元素的样式改变不影响其几何位置时（例如 `background-color`, `color` 的改变），浏览器会跳过布局阶段，直接进入绘制阶段。这个过程称为**重绘 (Repaint)**。

## 6. 合成 (Compositing)

在绘制之后，为了进一步提升性能，现代浏览器引入了**图层 (Layer)** 和**合成**机制。

*   **图层提升**：浏览器会将页面的某些部分（例如有 `transform: translateZ(0)` 或 `will-change` 属性的元素）提升为独立的图层。
*   **独立绘制**：每个图层会被独立地进行栅格化（Rasterization），即转换成位图。
*   **合成**：最后，GPU 进程会将所有这些图层按照正确的顺序和位置合成为一个完整的页面，然后显示在屏幕上。

**合成的优势**：对于那些只影响图层变换（如 `transform`, `opacity`）的动画，浏览器可以跳过布局和绘制，直接在 GPU 中进行图层合成。这极大地提高了动画的流畅度，因为它完全脱离了主线程的负担。
