# 07-JS核心理论：执行上下文、作用域链与闭包

要真正掌握 JavaScript，就必须理解其代码在执行时内部发生了什么。执行上下文、作用域链和闭包是 JS 语言最核心、最底层的概念，它们共同决定了变量和函数的可访问性以及 `this` 的指向。

## 1. 执行上下文 (Execution Context, EC)

**执行上下文**可以理解为是 JavaScript 代码被**执行时**所需的环境。当 JS 引擎运行代码时，它会为不同类型的代码创建不同类型的执行上下文。

*   **全局执行上下文 (Global EC)**：这是最基础的上下文。当 JS 文件被加载和执行时，引擎会首先创建一个全局执行上下文。这个上下文在整个页面生命周期中只有一个，并且在浏览器关闭时被销毁。在浏览器环境中，全局对象就是 `window`，`this` 在全局上下文中也指向 `window`。
*   **函数执行上下文 (Function EC)**：每当一个**函数被调用**时，就会为该函数创建一个新的执行上下文。每个函数都有自己独立的执行上下文。
*   **Eval 执行上下文**：通过 `eval()` 函数执行的代码也有自己的执行上下文（不推荐使用）。

### 执行上下文的创建过程

一个执行上下文的创建分为两个阶段：**创建阶段**和**执行阶段**。

#### a. 创建阶段 (Creation Phase)

在代码被逐行执行**之前**，JS 引擎会先在“幕后”做一些准备工作，即创建执行上下文。这个阶段发生了三件重要的事情：

1.  **确定 `this` 的值 (This Binding)**：
    *   在全局上下文中，`this` 指向全局对象 (`window`)。
    *   在函数上下文中，`this` 的值取决于函数的**调用方式**（谁调用了它），而不是定义方式。

2.  **创建词法环境 (Lexical Environment)**：
    *   **词法环境**是一个内部数据结构，用于存储当前上下文中的**变量和函数声明**。它由两部分组成：
        *   **环境记录 (Environment Record)**：存储变量和函数声明的实际位置。
        *   **对外部环境的引用 (Outer Environment Reference)**：一个指向其**外部**词法环境的链接，这构成了作用域链的基础。
    *   在这个阶段，JS 引擎会扫描当前上下文中的函数声明、`var` 变量声明，并将它们记录下来。这就是**变量提升 (Hoisting)** 的来源：
        *   对于**函数声明 (function declaration)**，会完整地创建函数并存储其引用。
        *   对于 **`var` 声明的变量**，会为其分配内存并初始化为 `undefined`。
        *   对于 **`let` 和 `const` 声明的变量**，也会被记录下来，但**不会被初始化**。它们被置于一个“**暂时性死区 (Temporal Dead Zone, TDZ)**”中，在声明语句执行之前访问它们会抛出错误。

3.  **创建变量环境 (Variable Environment)**：
    *   它也是一个词法环境，但只用于存储 `var` 声明的变量。`let` 和 `const` 的声明则存储在词法环境中。

#### b. 执行阶段 (Execution Phase)

在创建阶段完成后，JS 引擎开始逐行执行代码。在这个阶段，引擎会完成变量的赋值、执行函数调用等操作。

## 2. 调用栈 (Call Stack)

我们在“事件循环”一章中已经介绍过调用栈。现在我们可以更精确地定义它：调用栈是一个后进先出（LIFO）的栈，专门用于**存储和管理执行上下文**。

*   当 JS 引擎开始执行代码时，它首先将**全局执行上下文**压入栈底。
*   每当一个函数被调用时，就会创建一个新的**函数执行上下文**，并将其压入栈顶。
*   当栈顶的函数执行完毕后，其对应的执行上下文就会从栈中弹出。
*   最终，当所有代码执行完毕，全局执行上下文也会被弹出，调用栈清空。

## 3. 作用域链 (Scope Chain)

**作用域 (Scope)** 定义了变量和函数在代码中的可访问区域。JavaScript 采用的是**词法作用域 (Lexical Scoping)**，也叫静态作用域。

*   **词法作用域**：意味着变量和函数的可访问性，在**代码编写时**就已经被确定下来了，并且不会在运行时改变。它取决于代码块（`{}`）和函数的嵌套关系。

**作用域链**是在执行上下文的**创建阶段**，通过**词法环境**的“**对外部环境的引用 (Outer)**”这个链接建立起来的。

*   **工作原理**：当代码在一个执行环境中需要访问一个变量时：
    1.  JS 引擎首先在**当前**执行上下文的词法环境中查找。
    2.  如果找不到，它就会顺着“外部环境引用”这个“链条”，去**外部**（父级）的词法环境中查找。
    3.  这个过程会一直持续下去，沿着作用域链一直向上，直到找到该变量，或者到达最顶层的**全局执行上下文**。
    4.  如果在全局上下文中仍然找不到，就会抛出 `ReferenceError`。

## 4. 闭包 (Closure)

**闭包**是 JavaScript 中一个强大而独特的概念。一个被广为接受的定义是：

> **当一个函数能够记住并访问其所在的词法作用域时，即使该函数在其词法作用域之外执行，也会产生闭包。**

简单来说，闭包就是 **“一个函数”** 和 **“它在创建时所能访问的作用域”** 的组合。

```javascript
function outer() {
  const outerVar = 'I am outside!';
  
  function inner() {
    // inner 函数访问了其外部函数 outer 的变量 outerVar
    console.log(outerVar);
  }
  
  return inner; // 返回了 inner 函数
}

const myClosure = outer(); // outer() 执行完毕，其执行上下文已从调用栈中弹出
myClosure(); // 但 inner 函数依然可以访问 outerVar，输出 "I am outside!"
```

### 闭包的原理

*   在 `outer` 函数被调用时，创建了 `outer` 的执行上下文，其词法环境中包含了 `outerVar`。
*   `inner` 函数在 `outer` 函数**内部定义**，所以 `inner` 的词法环境中的“外部环境引用”指向了 `outer` 的词法环境。
*   当 `outer` 函数返回 `inner` 函数时，`inner` 函数本身被赋值给了 `myClosure`。
*   关键点：由于 `inner` 函数仍然存活（被 `myClosure` 引用），并且它持有对其创建时所在词法环境（即 `outer` 的词法环境）的引用，**垃圾回收机制（GC）就不会回收 `outer` 的词法环境**，特别是被 `inner` 使用到的 `outerVar`。
*   因此，当 `myClosure()`（即 `inner` 函数）在全局作用域中被调用时，它仍然可以通过其内部的作用域链，找到并访问那个本应“消失”的 `outerVar`。

### 闭包的应用与注意事项

*   **应用**：
    *   **数据封装与私有变量**：创建只有内部函数才能访问的“私有”变量。
    *   **模块化**：在模块模式中用于创建私有作用域。
    *   **函数柯里化、高阶函数**等。
*   **注意事项**：
    *   **内存泄漏**：由于闭包会使其外部作用域的变量持续存在于内存中，如果不当使用（例如，在一个不再需要的闭包中意外地引用了一个大对象），可能会导致内存泄漏。
