# 06-浏览器垃圾回收（GC）机制

垃圾回收（Garbage Collection, GC）是一种自动内存管理的机制。在 JavaScript 中，开发者无需（也无法）手动分配和释放内存，这些工作都由 JS 引擎（如 V8）在后台自动完成。GC 的核心任务是**找出那些不再被使用的内存（垃圾），并将其回收，以便后续代码可以重新利用这部分空间**。

V8 的垃圾回收策略是基于**分代假说（Generational Hypothesis）** 的，这个假说有两个核心特点：
1.  **大部分对象“朝生夕死”**：它们在被创建后很快就不再被需要。
2.  **“老”对象，很少“死”**：存活时间越长的对象，就越有可能持续存活下去。

基于这个假说，V8 将其堆内存（Heap）分为了两个主要区域：**新生代（Young Generation）** 和 **老生代（Old Generation）**。

## 1. 新生代 (Young Generation)

*   **特点**：用于存放存活时间较短的新对象。新生代空间较小（通常只有几 MB），但垃圾回收非常频繁。
*   **回收算法**：**Scavenge（清除）算法**，这是一种典型的“以空间换时间”的策略。

### Scavenge 算法流程

新生代内存被平均分成了两块相等的空间：**From 空间（使用中）** 和 **To 空间（空闲）**。

1.  **分配**：所有新创建的对象首先都会被分配在 **From 空间**。
2.  **标记**：当 From 空间即将被占满时，GC 开始工作。它会从根对象（如全局对象 `window`）出发，遍历所有可达的**活动对象**，并给它们做一个标记。
3.  **复制与整理**：GC 将所有被标记的**活动对象**从 From 空间复制到 **To 空间**，并进行内存整理，使它们在 To 空间中紧凑地排列。那些没有被标记的非活动对象（垃圾）则被留在 From 空间。
4.  **清空与角色互换**：复制完成后，整个 From 空间内的对象都被视为垃圾，可以被一次性清空。然后，From 空间和 To 空间的角色发生互换。原来的 To 空间变成了新的 From 空间，继续进行对象分配；原来的 From 空间则变成了新的 To 空间，等待下一次 GC。

### 对象的晋升 (Promotion)

如果在一次 Scavenge 回收过程中，一个对象依然存活，那么它就被认为是经历了一轮回收。如果一个对象连续经历了**两轮**回收依然存活，V8 就会认为它是一个存活时间较长的对象，并将其**晋升**到**老生代**内存区。

此外，如果复制一个对象到 To 空间时，发现 To 空间的使用率已经超过了 25%，那么这个对象也会被直接晋升到老生代。

## 2. 老生代 (Old Generation)

*   **特点**：用于存放存活时间较长的对象（从新生代晋升而来）以及一些较大的对象。老生代空间较大，垃圾回收的频率相对较低。
*   **回收算法**：**Mark-Sweep（标记-清除）** 和 **Mark-Compact（标记-整理）** 相结合。

### a. Mark-Sweep (标记-清除)

由于老生代的对象数量多、存活率高，如果再使用 Scavenge 算法（需要复制大量对象）会非常低效。因此，老生代采用 Mark-Sweep 算法。

1.  **标记 (Marking)**：GC 从根对象开始，遍历堆中所有可达的**活动对象**，并打上标记。
2.  **清除 (Sweeping)**：遍历整个堆内存，将所有**没有被标记**的对象（垃圾）进行回收，并清除它们的内存。

**缺点**：Mark-Sweep 会在内存中产生大量不连续的**内存碎片**。如果后续需要分配一个较大的对象，可能会因为找不到足够大的连续内存空间而失败。

### b. Mark-Compact (标记-整理)

为了解决内存碎片问题，V8 引入了 Mark-Compact 算法。它通常在 Mark-Sweep 执行多次，空间碎片化问题变得比较严重时才会被触发。

1.  **标记 (Marking)**：同 Mark-Sweep。
2.  **整理 (Compacting)**：在标记完成后，此算法会将所有**活动对象**向内存的一端移动，使它们紧凑地排列。移动完成后，直接清理掉边界以外的所有内存。

**缺点**：移动对象的过程会比较耗时。

因此，V8 在老生代主要使用 Mark-Sweep，并在必要时才使用 Mark-Compact 来处理内存碎片。

## 3. 全停顿 (Stop-The-World)

需要注意的是，由于 JavaScript 是单线程的，**在进行垃圾回收时，JS 脚本的执行必须暂停**，这个现象被称为“**全停顿（Stop-The-World）**”。

为了优化用户体验，V8 引入了许多先进技术，如**增量标记（Incremental Marking）**、**并行回收（Parallel GC）** 和 **并发回收（Concurrent GC）**，旨在将 GC 的停顿时间打散成许多小段，或者在不暂停主线程的后台线程中完成部分 GC 工作，从而尽可能地减少对应用性能的影响。

## 4. 常见的内存泄漏场景

内存泄漏是指程序中已分配的内存，由于某种原因程序未释放或无法释放，造成系统内存的浪费。常见的场景有：

*   **意外的全局变量**：未声明的变量被附加到全局对象上。
*   **闭包使用不当**：闭包会使其内部函数持有外部作用域的引用，如果这些引用不再需要但没有被解除，就会导致内存泄漏。
*   **被遗忘的定时器**：`setInterval` 如果没有被 `clearInterval`，其回调函数及其依赖的变量将一直无法被回收。
*   **分离的 DOM 节点**：一个 DOM 节点从 DOM 树中被移除了，但仍然有一个 JavaScript 变量在引用它。
