# 13-浏览器缓存机制详解

浏览器缓存，也称为 HTTP 缓存，是 Web 性能优化的核心策略。它允许浏览器将一度请求过的资源（如图片、CSS、JS 文件）存储在本地，当再次需要该资源时，可以直接从本地存储中读取或通过简单的验证后使用，从而避免了不必要的网络请求。

浏览器缓存机制主要分为两大类：**强缓存** 和 **协商缓存**。

## 1. 强缓存 (Strong Cache)

*   **定义**：强缓存是指浏览器在请求资源时，如果发现本地缓存的副本**未过期**，就**不会向服务器发送任何请求**，而是直接从本地缓存中读取该资源。
*   **状态码**：在这种情况下，网络请求甚至不会发生，因此在 Chrome DevTools 的 Network 面板中，该资源的状态码会显示为 `200 OK (from disk cache)` 或 `200 OK (from memory cache)`。
*   **优点**：速度最快，因为它完全避免了网络往返。

强缓存是由服务器通过设置响应头中的特定字段来控制的。主要有两个相关的头部，它们可以同时存在，但优先级不同。

### a. `Expires` (HTTP/1.0)

*   **格式**：`Expires: Wed, 22 Oct 2025 08:28:00 GMT`
*   **原理**：`Expires` 的值是一个**绝对时间**的 GMT 格式字符串，它告诉浏览器该资源的缓存副本在此时间点之前都是有效的。
*   **缺点**：由于它是一个绝对时间，如果客户端的本地时间与服务器时间不一致（例如用户手动修改了本地时间），可能会导致缓存提前失效或永远有效，存在不确定性。

### b. `Cache-Control` (HTTP/1.1) - 优先级更高

*   **格式**：`Cache-Control: max-age=3600`
*   **原理**：`Cache-Control` 是 HTTP/1.1 中引入的，功能更强大。它使用一个**相对时间** `max-age`（单位为秒）来告诉浏览器，资源在被请求后的 `3600` 秒内都是有效的。
*   **优点**：`max-age` 使用相对时间，不受客户端本地时间的影响，比 `Expires` 更精确、更可靠。
*   **其他常用指令**：
    *   `no-cache`：**强制进行协商缓存**。浏览器在每次请求前，都必须向服务器发送验证请求，确认资源是否依然有效。
    *   `no-store`：**完全禁用缓存**。浏览器既不使用本地缓存，也不存储该资源的任何副本。
    *   `public`：表明该资源可以被任何中间代理（如 CDN、代理服务器）缓存。
    *   `private`：表明该资源是用户私有的，只能被最终用户的浏览器缓存，不允许中间代理缓存。

**当 `Cache-Control` 和 `Expires` 同时存在时，`Cache-Control` 的优先级更高。**

### c. 强缓存的存储位置：Memory Cache vs Disk Cache

当强缓存生效时，我们会在 Chrome DevTools 的 Network 面板中看到 `(from memory cache)` 或 `(from disk cache)`。这表示缓存资源是存储在**内存**还是**磁盘**中。

*   **Memory Cache (内存缓存)**
    *   **优点**：读取速度极快，因为数据直接存储在内存中，没有 I/O 开销。
    *   **缺点**：生命周期短。一旦我们关闭了浏览器标签页，该页面对应的内存缓存就会被清空。
    *   **存储内容**：浏览器会倾向于将体积小、访问频繁的资源（如脚本、字体、小图片）放入内存缓存。

*   **Disk Cache (磁盘缓存)**
    *   **优点**：容量大，持久性强。即使关闭浏览器甚至重启电脑，磁盘缓存依然存在（只要没过期）。
    *   **缺点**：读取速度比内存缓存慢，需要进行磁盘 I/O 操作。
    *   **存储内容**：体积较大的资源（如大的图片、CSS/JS 文件）会被优先存入磁盘缓存。

**读取顺序**：当浏览器请求一个资源时，会**优先在内存缓存中查找**，如果找到则直接使用。如果内存中没有，再去磁盘缓存中查找。如果两者都没有，才会发起网络请求。这种“内存优先”的策略确保了最快的响应速度。

## 2. 协商缓存 (Negotiation Cache)

*   **定义**：当资源的强缓存失效后（或者 `Cache-Control` 设置为 `no-cache`），浏览器在请求该资源时，会**向服务器发送一个验证请求**。服务器会根据请求中携带的缓存标识来判断资源是否有更新。
*   **工作流程**：
    *   如果资源**未更新**，服务器会返回一个 `304 Not Modified` 的响应，响应体为空。浏览器接收到后，就知道可以使用本地缓存的副本。
    *   如果资源**已更新**，服务器会返回一个 `200 OK` 的响应，并在响应体中包含最新的资源内容。
*   **优点**：虽然仍然有一次网络请求，但如果资源未变更，可以避免传输完整的响应体，从而节省网络带宽。

协商缓存也是通过一对对的请求头和响应头来工作的。

### a. `Last-Modified` / `If-Modified-Since`

1.  **首次请求**：服务器在响应头中返回 `Last-Modified` 字段，表示该资源在服务器上的最后修改时间。
    `Last-Modified: Tue, 12 Oct 2025 10:00:00 GMT`
2.  **后续请求**：当缓存过期后，浏览器在请求头中携带 `If-Modified-Since` 字段，其值就是上次收到的 `Last-Modified` 的值。
    `If-Modified-Since: Tue, 12 Oct 2025 10:00:00 GMT`
3.  **服务器验证**：服务器比较 `If-Modified-Since` 的值和资源的实际最后修改时间。
    *   如果一致，说明资源未变，返回 `304`。
    *   如果不一致，说明资源已更新，返回 `200` 和新资源，并附带一个新的 `Last-Modified` 值。

*   **缺点**：
    *   **精度问题**：时间戳的精度只能到秒，如果在 1 秒内文件被多次修改，服务器无法检测到变化。
    *   **内容未变但时间戳改变**：有时文件内容没有实际变化，但其修改时间却变了（例如重新保存），这会导致缓存失效。

### b. `ETag` / `If-None-Match` - 优先级更高

为了解决 `Last-Modified` 的问题，HTTP/1.1 引入了 `ETag` (Entity Tag)。

1.  **首次请求**：服务器在响应头中返回 `ETag` 字段，这是一个根据资源内容生成的**唯一标识符**（类似于文件内容的哈希值）。
    `ETag: "33a64df551425fcc55e4d42a148795d9"`
2.  **后续请求**：当缓存过期后，浏览器在请求头中携带 `If-None-Match` 字段，其值就是上次收到的 `ETag` 的值。
    `If-None-Match: "33a64df551425fcc55e4d42a148795d9"`
3.  **服务器验证**：服务器比较 `If-None-Match` 的值和资源当前的 `ETag` 值。
    *   如果一致，说明资源未变，返回 `304`。
    *   如果不一致，说明资源已更新，返回 `200` 和新资源，并附带一个新的 `ETag` 值。

*   **优点**：`ETag` 基于内容生成，比基于时间戳的 `Last-Modified` 更精确、更可靠。

**当 `ETag` 和 `Last-Modified` 同时存在时，服务器会优先验证 `ETag`。**

## 3. 缓存决策流程总结

当浏览器请求一个资源时，会按照以下流程来决策：

1.  **检查强缓存**：查看本地缓存副本，根据 `Cache-Control` 和 `Expires` 判断是否过期。
    *   如果**未过期**，直接使用缓存（`200 from cache`），流程结束。
    *   如果**已过期**，进入下一步。
2.  **发起协商缓存请求**：向服务器发送请求，并在请求头中携带 `If-Modified-Since` 和 `If-None-Match`。
3.  **服务器验证**：服务器根据收到的缓存标识进行判断。
    *   如果资源**未更新**，返回 `304`。浏览器使用本地缓存，流程结束。
    *   如果资源**已更新**，返回 `200` 和最新的资源内容。浏览器使用新资源，并更新本地缓存及其过期信息，流程结束。

## 4. 用户行为对缓存的影响

*   **地址栏输入 URL / 书签 / 前进后退**：正常检查缓存。
*   **F5 / 点击刷新按钮**：会跳过**强缓存**，直接发起**协商缓存**请求（请求头会带 `If-Modified-Since` / `If-None-Match`）。
*   **Ctrl + F5 强制刷新**：会**完全忽略**所有缓存，直接向服务器请求全新的资源（请求头不会带任何缓存标识）。
